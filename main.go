package main

import (
	"context"
	_ "embed"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"strings"
	"sync"
	"syscall"

	"github.com/s3rj1k/ninit/pkg/config"
	"github.com/s3rj1k/ninit/pkg/reaper"
	"github.com/s3rj1k/ninit/pkg/signals"
	"github.com/s3rj1k/ninit/pkg/utils"
	"github.com/s3rj1k/ninit/pkg/watch"
)

var (
	//go:embed version.autogenerated
	version string
	//go:embed buildTime.autogenerated
	buildTime string
)

func main() {
	if len(os.Args) > 1 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		config.Help(
			config.DefaultEnvPrefix,
			filepath.Base(os.Args[0]),
			strings.TrimSpace(version),
			strings.TrimSpace(buildTime),
		)
		os.Exit(0)
	}

	log.SetPrefix(config.DefaultLogPrefix)
	log.SetFlags(log.Lmsgprefix) // log.Lshortfile | log.Lmsgprefix

	if os.Getpid() != 1 {
		log.Fatalf("expecting to be run as PID 1, exiting\n")
	}

	c, err := config.Get(config.DefaultEnvPrefix)
	if err != nil {
		log.Fatalf("%v\n", err)
	}

	var wg sync.WaitGroup

	if err := run(c, &wg); err != nil {
		if exitErr, ok := err.(*exec.ExitError); ok {
			log.Printf("command exited with code: %d, %v\n", exitErr.ExitCode(), err)
		} else {
			log.Printf("unexpected error: %v\n", err)
		}
	}

	wg.Wait()
}

func run(c *config.Config, wg *sync.WaitGroup) error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigs := make(chan os.Signal, 1)
	defer close(sigs)

	signal.Notify(
		sigs,
		signals.Except(syscall.SIGCHLD, syscall.SIGCLD)..., // "17", "SIGCHLD", "SIGCLD": only useful for zombie reaping
	)
	defer signal.Reset()

	cmd := exec.CommandContext(
		ctx,
		c.CommandPath,
		c.CommandArgs...,
	)

	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if c.WorkDirectory != "" {
		cmd.Dir = c.WorkDirectory
	}

	cmd.Env = utils.FilterStringSlice(
		os.Environ(),
		func(x string) bool {
			return !strings.HasPrefix(x, c.EnvPrefix)
		},
	)

	cmd.SysProcAttr = &syscall.SysProcAttr{
		// create a dedicated pidgroup for signal forwarding
		Setpgid: true,
	}

	if err := cmd.Start(); err != nil {
		return err
	}

	log.Printf("started process '%v' with PID '%d'\n", cmd.String(), cmd.Process.Pid)

	watch := watch.Path(ctx, wg, c.WatchPath, c.WatchInterval)
	reap := reaper.Run(ctx, wg)

	wg.Add(1)

	go func() {
		sendSignal := func(pid int, sig syscall.Signal) {
			// forward signal to main process and all children
			if err := syscall.Kill(pid, sig); err != nil {
				if err != syscall.ESRCH { // no such process
					log.Printf("%v\n", err)
				}

				return
			}

			log.Printf("sent '%v' signal to PID '%d'\n", sig, pid)
		}

		for {
			select {
			case <-ctx.Done():
				wg.Done()
				return

			case sig := <-sigs:
				if sig == nil || sig == syscall.SIGCHLD {
					continue
				}

				// log.Printf("received OS signal %v\n", sig) // can be very verbose

				if v, ok := sig.(syscall.Signal); ok {
					sendSignal(-cmd.Process.Pid, v)
				}

			case v := <-watch:
				if v.Error != nil {
					log.Printf("%v\n", v.Error)
				}

				if v.Message != "" {
					log.Printf("%v\n", v.Message)
				}

				if v.IsChanged {
					sendSignal(-cmd.Process.Pid, c.ReloadSignal)
				}

			case v := <-reap:
				if v != "" {
					log.Printf("%v\n", v)
				}
			}
		}
	}()

	return cmd.Wait()
}
